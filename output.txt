preproc directive: `#include <stdio.h>`
preproc directive: `#include <stdlib.h>`
preproc directive: `#include <string.h>`
preproc directive: `#include <stdbool.h>`
preproc directive: `#include <ctype.h>`
preproc directive: `#define MAX_TKN_SIZE 256`
preproc directive: `#define NUM_KEYWORDS 32`
preproc directive: `#define NUM_OPERATORS 31`
preproc directive: `#define KEYWORD_MAX_SIZE 10`
preproc directive: `#define OPERATOR_MAX_SIZE 4`
single line comment: ` all possible states`
keyword: `typedef`
keyword: `enum`
identifier: `State`
punctuation: `{`
identifier: `ST_KEYWORD`
punctuation: `,`
identifier: `ST_OPERATOR`
punctuation: `,`
identifier: `ST_STRING_LITERAL`
punctuation: `,`
identifier: `ST_CHAR_LITERAL`
punctuation: `,`
identifier: `ST_INTEGER_CONSTANT`
punctuation: `,`
identifier: `ST_FLOATING_POINT_CONSTANT`
punctuation: `,`
identifier: `ST_COMMENT`
punctuation: `,`
identifier: `ST_COMMENT_SINGLE_LINE`
punctuation: `,`
identifier: `ST_COMMENT_MULTI_LINE`
punctuation: `,`
identifier: `ST_IDENTIFIER`
punctuation: `,`
identifier: `ST_PROCESS_DIGIT`
punctuation: `,`
identifier: `ST_PROCESS_ALPHA`
punctuation: `,`
identifier: `ST_PUNCTUATION`
punctuation: `,`
identifier: `ST_PREPROCESSOR_DIRECTIVE`
punctuation: `,`
identifier: `ST_INITIAL_STATE`
punctuation: `,`
punctuation: `}`
identifier: `State`
punctuation: `;`
Multi line comment: `Test
Multi line`
keyword: `const`
keyword: `char`
identifier: `language_keywords`
punctuation: `[`
identifier: `NUM_KEYWORDS`
punctuation: `]`
punctuation: `[`
identifier: `KEYWORD_MAX_SIZE`
punctuation: `]`
operator: `=`
punctuation: `{`
string constant: `auto`
punctuation: `,`
string constant: `break`
punctuation: `,`
string constant: `case`
punctuation: `,`
string constant: `char`
punctuation: `,`
string constant: `const`
punctuation: `,`
string constant: `continue`
punctuation: `,`
string constant: `default`
punctuation: `,`
string constant: `do`
punctuation: `,`
string constant: `double`
punctuation: `,`
string constant: `else`
punctuation: `,`
string constant: `enum`
punctuation: `,`
string constant: `extern`
punctuation: `,`
string constant: `float`
punctuation: `,`
string constant: `for`
punctuation: `,`
string constant: `goto`
punctuation: `,`
string constant: `if`
punctuation: `,`
string constant: `int`
punctuation: `,`
string constant: `long`
punctuation: `,`
string constant: `register`
punctuation: `,`
string constant: `return`
punctuation: `,`
string constant: `short`
punctuation: `,`
string constant: `signed`
punctuation: `,`
string constant: `sizeof`
punctuation: `,`
string constant: `static`
punctuation: `,`
string constant: `struct`
punctuation: `,`
string constant: `switch`
punctuation: `,`
string constant: `typedef`
punctuation: `,`
string constant: `union`
punctuation: `,`
string constant: `unsigned`
punctuation: `,`
string constant: `void`
punctuation: `,`
string constant: `volatile`
punctuation: `,`
string constant: `while`
punctuation: `}`
punctuation: `;`
keyword: `const`
keyword: `char`
identifier: `language_operators`
punctuation: `[`
identifier: `NUM_OPERATORS`
punctuation: `]`
punctuation: `[`
identifier: `OPERATOR_MAX_SIZE`
punctuation: `]`
operator: `=`
punctuation: `{`
string constant: `!`
punctuation: `,`
string constant: `|`
punctuation: `,`
string constant: `^`
punctuation: `,`
string constant: `&`
punctuation: `,`
string constant: `~`
punctuation: `,`
string constant: `>`
punctuation: `,`
string constant: `<`
punctuation: `,`
string constant: `=`
punctuation: `,`
string constant: `-`
punctuation: `,`
string constant: `+`
punctuation: `,`
string constant: `*`
punctuation: `,`
string constant: `/`
punctuation: `,`
string constant: `%%`
punctuation: `,`
string constant: `==`
punctuation: `,`
string constant: `+=`
punctuation: `,`
string constant: `-=`
punctuation: `,`
string constant: `|=`
punctuation: `,`
string constant: `&=`
punctuation: `,`
string constant: `^=`
punctuation: `,`
string constant: `!=`
punctuation: `,`
string constant: `++`
punctuation: `,`
string constant: `<<`
punctuation: `,`
string constant: `>>`
punctuation: `,`
string constant: `--`
punctuation: `,`
string constant: `<=`
punctuation: `,`
string constant: `>=`
punctuation: `,`
string constant: `*=`
punctuation: `,`
string constant: `/=`
punctuation: `,`
string constant: `%%=`
punctuation: `,`
string constant: `<<=`
punctuation: `,`
string constant: `>>=`
punctuation: `}`
punctuation: `;`
keyword: `const`
keyword: `char`
identifier: `punctuation`
punctuation: `[`
punctuation: `]`
operator: `=`
string constant: `(){}[],.;:?`
punctuation: `;`
keyword: `const`
keyword: `char`
identifier: `operators_characters`
punctuation: `[`
punctuation: `]`
operator: `=`
string constant: `|&^~!<>=+-*/%%`
punctuation: `;`
identifier: `bool`
identifier: `is_keyword`
punctuation: `(`
keyword: `const`
keyword: `char`
operator: `*`
identifier: `str`
punctuation: `)`
punctuation: `{`
keyword: `for`
punctuation: `(`
keyword: `int`
identifier: `i`
operator: `=`
integer constant: 0
punctuation: `;`
identifier: `i`
operator: `<`
integer constant: 32
punctuation: `;`
identifier: `i`
operator: `++`
punctuation: `)`
keyword: `if`
punctuation: `(`
identifier: `strcmp`
punctuation: `(`
identifier: `str`
punctuation: `,`
identifier: `language_keywords`
punctuation: `[`
identifier: `i`
punctuation: `]`
punctuation: `)`
operator: `==`
integer constant: 0
punctuation: `)`
keyword: `return`
identifier: `true`
punctuation: `;`
keyword: `return`
identifier: `false`
punctuation: `;`
punctuation: `}`
identifier: `bool`
identifier: `is_operator`
punctuation: `(`
keyword: `const`
keyword: `char`
operator: `*`
identifier: `str`
punctuation: `)`
punctuation: `{`
keyword: `for`
punctuation: `(`
keyword: `int`
identifier: `i`
operator: `=`
integer constant: 0
punctuation: `;`
identifier: `i`
operator: `<`
integer constant: 32
punctuation: `;`
identifier: `i`
operator: `++`
punctuation: `)`
keyword: `if`
punctuation: `(`
identifier: `strcmp`
punctuation: `(`
identifier: `str`
punctuation: `,`
identifier: `language_operators`
punctuation: `[`
identifier: `i`
punctuation: `]`
punctuation: `)`
operator: `==`
integer constant: 0
punctuation: `)`
keyword: `return`
identifier: `true`
punctuation: `;`
keyword: `return`
identifier: `false`
punctuation: `;`
punctuation: `}`
keyword: `int`
identifier: `lexer`
punctuation: `(`
identifier: `FILE`
operator: `*`
identifier: `fp`
punctuation: `)`
punctuation: `{`
identifier: `bool`
identifier: `running`
operator: `=`
identifier: `true`
punctuation: `;`
identifier: `State`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
keyword: `char`
identifier: `currentChar`
punctuation: `;`
keyword: `int`
identifier: `numCharactersRead`
operator: `=`
integer constant: 0
punctuation: `;`
keyword: `char`
identifier: `currentToken`
punctuation: `[`
identifier: `MAX_TKN_SIZE`
punctuation: `]`
punctuation: `;`
keyword: `while`
punctuation: `(`
identifier: `running`
punctuation: `)`
punctuation: `{`
keyword: `switch`
punctuation: `(`
identifier: `currentState`
punctuation: `)`
punctuation: `{`
single line comment: ` initial state is reached at the beginning of the file,`
single line comment: ` or when the previous token was fully consumed`
keyword: `case`
identifier: `ST_INITIAL_STATE`
punctuation: `:`
punctuation: `{`
identifier: `numCharactersRead`
operator: `=`
integer constant: 0
punctuation: `;`
identifier: `memset`
punctuation: `(`
identifier: `currentToken`
punctuation: `,`
integer constant: 0
punctuation: `,`
identifier: `MAX_TKN_SIZE`
operator: `*`
keyword: `sizeof`
punctuation: `(`
keyword: `char`
punctuation: `)`
punctuation: `)`
punctuation: `;`
identifier: `currentChar`
operator: `=`
punctuation: `(`
keyword: `char`
punctuation: `)`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `feof`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `)`
punctuation: `{`
identifier: `running`
operator: `=`
identifier: `false`
punctuation: `;`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `if`
punctuation: `(`
identifier: `isspace`
punctuation: `(`
identifier: `currentChar`
punctuation: `)`
punctuation: `)`
keyword: `continue`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `==`
character constant: `\'`
punctuation: `{`
identifier: `currentState`
operator: `=`
identifier: `ST_CHAR_LITERAL`
punctuation: `;`
keyword: `continue`
punctuation: `;`
punctuation: `}`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `==`
character constant: `\"`
punctuation: `{`
identifier: `currentState`
operator: `=`
identifier: `ST_STRING_LITERAL`
punctuation: `;`
keyword: `continue`
punctuation: `;`
punctuation: `}`
keyword: `if`
punctuation: `(`
identifier: `isdigit`
punctuation: `(`
identifier: `currentChar`
punctuation: `)`
punctuation: `)`
identifier: `currentState`
operator: `=`
identifier: `ST_PROCESS_DIGIT`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `isalpha`
punctuation: `(`
identifier: `currentChar`
punctuation: `)`
punctuation: `)`
identifier: `currentState`
operator: `=`
identifier: `ST_PROCESS_ALPHA`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `strchr`
punctuation: `(`
identifier: `punctuation`
punctuation: `,`
identifier: `currentChar`
punctuation: `)`
punctuation: `)`
identifier: `currentState`
operator: `=`
identifier: `ST_PUNCTUATION`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `strchr`
punctuation: `(`
identifier: `operators_characters`
punctuation: `,`
identifier: `currentChar`
punctuation: `)`
punctuation: `)`
identifier: `currentState`
operator: `=`
identifier: `ST_OPERATOR`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `==`
identifier: `currentState`
operator: `=`
identifier: `ST_PREPROCESSOR_DIRECTIVE`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `==`
punctuation: `{`
identifier: `currentState`
operator: `=`
identifier: `ST_COMMENT`
punctuation: `;`
keyword: `continue`
punctuation: `;`
punctuation: `}`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
single line comment: ` printf("initial state %c\n", currentChar);`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_PREPROCESSOR_DIRECTIVE`
punctuation: `:`
punctuation: `{`
identifier: `currentChar`
operator: `=`
punctuation: `(`
keyword: `char`
punctuation: `)`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `!=`
character constant: `\n`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
keyword: `else`
punctuation: `{`
identifier: `printf`
punctuation: `(`
string constant: `preproc directive: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
punctuation: `}`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_KEYWORD`
punctuation: `:`
punctuation: `{`
identifier: `printf`
punctuation: `(`
string constant: `keyword: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_OPERATOR`
punctuation: `:`
punctuation: `{`
identifier: `currentChar`
operator: `=`
punctuation: `(`
keyword: `char`
punctuation: `)`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `strchr`
punctuation: `(`
identifier: `operators_characters`
punctuation: `,`
identifier: `currentChar`
punctuation: `)`
punctuation: `)`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
keyword: `else`
punctuation: `{`
keyword: `if`
punctuation: `(`
operator: `!`
identifier: `feof`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `)`
identifier: `fseek`
punctuation: `(`
identifier: `fp`
punctuation: `,`
operator: `-`
integer constant: 1
punctuation: `,`
identifier: `SEEK_CUR`
punctuation: `)`
punctuation: `;`
identifier: `printf`
punctuation: `(`
string constant: `operator: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
punctuation: `}`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_PUNCTUATION`
punctuation: `:`
punctuation: `{`
identifier: `printf`
punctuation: `(`
string constant: `punctuation: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_STRING_LITERAL`
punctuation: `:`
punctuation: `{`
identifier: `currentChar`
operator: `=`
punctuation: `(`
keyword: `char`
punctuation: `)`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `!=`
character constant: `\"`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
keyword: `else`
punctuation: `{`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
character constant: `\0`
identifier: `printf`
punctuation: `(`
string constant: `string constant: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
punctuation: `}`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_CHAR_LITERAL`
punctuation: `:`
punctuation: `{`
identifier: `currentChar`
operator: `=`
punctuation: `(`
keyword: `char`
punctuation: `)`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `==`
character constant: `\\`
punctuation: `{`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
character constant: `\\`
identifier: `currentChar`
operator: `=`
punctuation: `(`
keyword: `char`
punctuation: `)`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
identifier: `printf`
punctuation: `(`
string constant: `character constant: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
punctuation: `}`
keyword: `else`
punctuation: `{`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
punctuation: `}`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_INTEGER_CONSTANT`
punctuation: `:`
punctuation: `{`
identifier: `printf`
punctuation: `(`
string constant: `integer constant: %s\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_FLOATING_POINT_CONSTANT`
punctuation: `:`
punctuation: `{`
identifier: `currentChar`
operator: `=`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `isdigit`
punctuation: `(`
identifier: `currentChar`
punctuation: `)`
punctuation: `)`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
keyword: `else`
punctuation: `{`
single line comment: ` printf("Found %hhd\n", currentChar);`
keyword: `if`
punctuation: `(`
operator: `!`
identifier: `feof`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `)`
identifier: `fseek`
punctuation: `(`
identifier: `fp`
punctuation: `,`
operator: `-`
integer constant: 1
punctuation: `,`
identifier: `SEEK_CUR`
punctuation: `)`
punctuation: `;`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
punctuation: `]`
operator: `=`
character constant: `\0`
identifier: `printf`
punctuation: `(`
string constant: `floating point constant: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
punctuation: `}`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_COMMENT`
punctuation: `:`
punctuation: `{`
identifier: `currentChar`
operator: `=`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `==`
identifier: `currentState`
operator: `=`
identifier: `ST_COMMENT_SINGLE_LINE`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `==`
identifier: `currentState`
operator: `=`
identifier: `ST_COMMENT_MULTI_LINE`
punctuation: `;`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_COMMENT_SINGLE_LINE`
punctuation: `:`
punctuation: `{`
identifier: `currentChar`
operator: `=`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `!=`
character constant: `\n`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
keyword: `else`
punctuation: `{`
identifier: `printf`
punctuation: `(`
string constant: `single line comment: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
punctuation: `}`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_COMMENT_MULTI_LINE`
punctuation: `:`
punctuation: `{`
identifier: `currentChar`
operator: `=`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `!=`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
keyword: `else`
punctuation: `{`
identifier: `currentChar`
operator: `=`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `==`
punctuation: `{`
identifier: `printf`
punctuation: `(`
string constant: `Multi line comment: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
punctuation: `}`
keyword: `else`
punctuation: `{`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `fseek`
punctuation: `(`
identifier: `fp`
punctuation: `,`
operator: `-`
integer constant: 1
punctuation: `,`
identifier: `SEEK_CUR`
punctuation: `)`
punctuation: `;`
punctuation: `}`
punctuation: `}`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_IDENTIFIER`
punctuation: `:`
punctuation: `{`
identifier: `printf`
punctuation: `(`
string constant: `identifier: `%s`\n`
punctuation: `,`
identifier: `currentToken`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INITIAL_STATE`
punctuation: `;`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_PROCESS_DIGIT`
punctuation: `:`
punctuation: `{`
single line comment: ` printf("Process digit\n");`
identifier: `currentChar`
operator: `=`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `isdigit`
punctuation: `(`
identifier: `currentChar`
punctuation: `)`
punctuation: `)`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
keyword: `else`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `==`
punctuation: `{`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_FLOATING_POINT_CONSTANT`
punctuation: `;`
punctuation: `}`
keyword: `else`
punctuation: `{`
keyword: `if`
punctuation: `(`
operator: `!`
identifier: `feof`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `)`
identifier: `fseek`
punctuation: `(`
identifier: `fp`
punctuation: `,`
operator: `-`
integer constant: 1
punctuation: `,`
identifier: `SEEK_CUR`
punctuation: `)`
punctuation: `;`
identifier: `currentState`
operator: `=`
identifier: `ST_INTEGER_CONSTANT`
punctuation: `;`
punctuation: `}`
keyword: `break`
punctuation: `;`
punctuation: `}`
keyword: `case`
identifier: `ST_PROCESS_ALPHA`
punctuation: `:`
punctuation: `{`
identifier: `currentChar`
operator: `=`
identifier: `getc`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `currentChar`
operator: `!=`
operator: `&&`
operator: `!`
identifier: `isalnum`
punctuation: `(`
identifier: `currentChar`
punctuation: `)`
punctuation: `)`
punctuation: `{`
keyword: `if`
punctuation: `(`
operator: `!`
identifier: `feof`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `)`
identifier: `fseek`
punctuation: `(`
identifier: `fp`
punctuation: `,`
operator: `-`
integer constant: 1
punctuation: `,`
identifier: `SEEK_CUR`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `is_keyword`
punctuation: `(`
identifier: `currentToken`
punctuation: `)`
punctuation: `)`
identifier: `currentState`
operator: `=`
identifier: `ST_KEYWORD`
punctuation: `;`
keyword: `else`
identifier: `currentState`
operator: `=`
identifier: `ST_IDENTIFIER`
punctuation: `;`
punctuation: `}`
keyword: `else`
punctuation: `{`
identifier: `currentToken`
punctuation: `[`
identifier: `numCharactersRead`
operator: `++`
punctuation: `]`
operator: `=`
identifier: `currentChar`
punctuation: `;`
punctuation: `}`
keyword: `break`
punctuation: `;`
punctuation: `}`
punctuation: `}`
punctuation: `}`
keyword: `return`
integer constant: 0
punctuation: `;`
punctuation: `}`
keyword: `int`
identifier: `lexer_init`
punctuation: `(`
keyword: `const`
keyword: `char`
operator: `*`
identifier: `file_path`
punctuation: `)`
punctuation: `{`
identifier: `FILE`
operator: `*`
identifier: `fp`
operator: `=`
identifier: `fopen`
punctuation: `(`
identifier: `file_path`
punctuation: `,`
string constant: `r`
punctuation: `)`
punctuation: `;`
keyword: `if`
punctuation: `(`
identifier: `fp`
operator: `==`
identifier: `NULL`
punctuation: `)`
punctuation: `{`
identifier: `perror`
punctuation: `(`
identifier: `file_path`
punctuation: `)`
punctuation: `;`
keyword: `return`
operator: `-`
integer constant: 1
punctuation: `;`
punctuation: `}`
keyword: `int`
identifier: `retVal`
operator: `=`
identifier: `lexer`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
identifier: `fclose`
punctuation: `(`
identifier: `fp`
punctuation: `)`
punctuation: `;`
keyword: `return`
identifier: `retVal`
punctuation: `;`
punctuation: `}`
keyword: `int`
identifier: `main`
punctuation: `(`
keyword: `int`
identifier: `argc`
punctuation: `,`
keyword: `char`
operator: `**`
identifier: `argv`
punctuation: `)`
punctuation: `{`
keyword: `if`
punctuation: `(`
identifier: `argc`
operator: `!=`
integer constant: 2
punctuation: `)`
punctuation: `{`
identifier: `fprintf`
punctuation: `(`
identifier: `stderr`
punctuation: `,`
string constant: `Usage: %s <input_file>\n`
punctuation: `,`
identifier: `argv`
punctuation: `[`
integer constant: 0
punctuation: `]`
punctuation: `)`
punctuation: `;`
identifier: `exit`
punctuation: `(`
identifier: `EXIT_FAILURE`
punctuation: `)`
punctuation: `;`
punctuation: `}`
keyword: `if`
punctuation: `(`
identifier: `lexer_init`
punctuation: `(`
identifier: `argv`
punctuation: `[`
integer constant: 1
punctuation: `]`
punctuation: `)`
operator: `==`
operator: `-`
integer constant: 1
punctuation: `)`
punctuation: `{`
identifier: `fprintf`
punctuation: `(`
identifier: `stderr`
punctuation: `,`
string constant: `Error while running the lexer\n`
punctuation: `)`
punctuation: `;`
identifier: `exit`
punctuation: `(`
identifier: `EXIT_FAILURE`
punctuation: `)`
punctuation: `;`
punctuation: `}`
keyword: `return`
integer constant: 0
punctuation: `;`
punctuation: `}`
